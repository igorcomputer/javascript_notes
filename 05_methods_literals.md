## Методы объектов литералов

__Создавать объекты можно по разному. Рассмотрим примеры создания объектов с помощью литералов и 
способы создания методов для таких объектов.__

```javascript 
//////////////////////////////////
// Метод внутри объекта (литеральная форма) 
//////////////////////////////////

let user = {
  name: "Джон",
  age: 30,
  user.sayHi = function(){
    console.log("Привет!"); 
  }
};

user.sayHi(); // Привет!

//////////////////////////////////
// Привязка метода к объекту
//////////////////////////////////

let user = {
  name: "Джон",
  age: 30,
};

// сначала объявляем
function sayHi() {
  alert("Привет!");
};

// затем добавляем в качестве метода
user.sayHi = sayHi;
user.sayHi(); // Привет!

///////////////////////////////////
// Сокращённая запись метода
///////////////////////////////////

// Вариант 1
user = {
  sayHi: function() {
    alert("Привет");
  }
};

// Вариант 2 (по сути тоже самое, что и Вариант 1) 
user = {
  sayHi() {
    alert("Привет");
  }
};
```

### Контекст объектов, this

```javascript
///////////////////////////////////
// Контекст в качестве ссылки на объект 
///////////////////////////////////

let user = {
  name: "Джон",
  age: 30,
  sayHi() {
    alert(user.name); // !Так делать не нужно (см. использование this) 
  }
};

user.sayHi(); // Джон

// Можно переопределить user и метод sayHi() вызовет ошибку
let admin = user;
user = null; // обнулим переменную для наглядности, теперь она не хранит ссылку на объект.
admin.sayHi(); // Ошибка! Внутри sayHi() используется user, которая больше не ссылается на объект! 

///////////////////////////////////
// Ключевое слово this в методе
///////////////////////////////////

let user = {
  name: "Джон",
  age: 30,
  sayHi() {
    // this - это "текущий объект" 
    alert(this.name);
  }
};

user.sayHi(); // Джон
```

### "this" не является фиксированным

В JavaScript ключевое слово «this» ведёт себя иначе, чем в большинстве других языков программирования. 
Оно может использоваться в любой функции.

__Как следствие отсутствия фиксированного this, возможны случаи потери контекста!__ 

```javascript
///////////////////////////////////
// this внутри функции 
///////////////////////////////////

function sayHi() {
  alert( this.name );
}

sayHi(); // object window (не в режиме 'use strict')
sayHi(); // undefined (в режиме 'use strict')

///////////////////////////////////
// Пример потери контекста 
/////////////////////////////////// 

let user = {
  name: "Джон",
  hi() { alert(this.name); }
}

// разделим получение метода объекта и его вызов в разных строках
let hi = user.hi;
hi(); // Ошибка, потому что значением this является undefined

// Здесь hi = user.hi сохраняет функцию в переменной, и далее в последней строке она вызывается полностью сама по себе, 
// без объекта, так что нет this.

```

### У стрелочных функций нет "this"

Стрелочные функции особенные: у них нет своего «собственного» this. 
Если мы используем this внутри стрелочной функции, то его значение берётся из внешней «нормальной» функции.

```javascript
//////////////////////////////////////////////
// Например, здесь arrow() использует значение this 
// из внешнего метода user.sayHi():
//////////////////////////////////////////////

let user = {
  firstName: "Илья",
  sayHi() {
    let arrow = () => alert(this.firstName);
    arrow();
  }
};

user.sayHi(); // Илья

//////////////////////////////////////////////
// Здесь внутри forEach использована стрелочная функция, 
// таким образом this.title в ней будет иметь точно такое же значение, 
// как в методе showList: group.title.
//////////////////////////////////////////////

let group = {
  title: "Our Group",
  students: ["John", "Pete", "Alice"],

  showList() {
    this.students.forEach(
      student => alert(this.title + ': ' + student)
    );
  }
};

group.showList(); 

//////////////////////////////////////////////
// Пример ошибки! 
//////////////////////////////////////////////

let group = {
  title: "Our Group",
  students: ["John", "Pete", "Alice"],

  showList() {
    this.students.forEach(function(student) {
      // Error: Cannot read property 'title' of undefined
      alert(this.title + ': ' + student)
    });
  }
};

group.showList();

// Ошибка возникает потому, что forEach по умолчанию выполняет функции с this, 
// равным undefined, и в итоге мы пытаемся обратиться к undefined.title.
// Это не влияет на стрелочные функции, потому что у них просто нет this.

```

__Ссылки:__

- https://learn.javascript.ru/object-methods
- https://learn.javascript.ru/arrow-functions

